<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <link href="//fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet" type="text/css">
  
  <style>
    .link {
      fill: none;
      stroke: #4fb9b5;
    }
    .glow {

      /* This trick adds a heavy white shadow around the text. */
      text-shadow:
       -1px -1px 3px white,
       -1px  1px 3px white,
        1px -1px 3px white,
        1px  1px 3px white;

    }
    text {
      font-family: "Open Sans", sans-serif;
      pointer-events: none;
    }
  </style>
</head>

<body>
  <script>
    chart = {
  const root = d3.hierarchy(data);

  root.x0 = dy / 2;
  root.y0 = 0;
  root.descendants().forEach((d, i) => {
    d.id = i;
    d._children = d.children;
    if (d.depth && d.data.name.length !== 7) d.children = null;
  });

  const svg = d3.create("svg")
      .attr("viewBox", [-margin.left, -margin.top, width, dx])
      .style("font", "10px sans-serif")
      .style("user-select", "none");

  const gLink = svg.append("g")
      .attr("fill", "none")
      .attr("stroke", "#555")
      .attr("stroke-opacity", 0.4)
      .attr("stroke-width", 1.5);

  const gNode = svg.append("g")
      .attr("cursor", "pointer")
      .attr("pointer-events", "all");

  function update(source) {
    const duration = d3.event && d3.event.altKey ? 2500 : 250;
    const nodes = root.descendants().reverse();
    const links = root.links();

    // Compute the new tree layout.
    tree(root);

    let left = root;
    let right = root;
    root.eachBefore(node => {
      if (node.x < left.x) left = node;
      if (node.x > right.x) right = node;
    });

    const height = right.x - left.x + margin.top + margin.bottom;

    const transition = svg.transition()
        .duration(duration)
        .attr("viewBox", [-margin.left, left.x - margin.top, width, height])
        .tween("resize", window.ResizeObserver ? null : () => () => svg.dispatch("toggle"));

    // Update the nodes…
    const node = gNode.selectAll("g")
      .data(nodes, d => d.id);

    // Enter any new nodes at the parent's previous position.
    const nodeEnter = node.enter().append("g")
        .attr("transform", d => `translate(${source.y0},${source.x0})`)
        .attr("fill-opacity", 0)
        .attr("stroke-opacity", 0)
        .on("click", (event, d) => {
          d.children = d.children ? null : d._children;
          update(d);
        });

    nodeEnter.append("circle")
        .attr("r", 2.5)
        .attr("fill", d => d._children ? "#555" : "#999")
        .attr("stroke-width", 10);

    nodeEnter.append("text")
        .attr("dy", "0.31em")
        .attr("x", d => d._children ? -6 : 6)
        .attr("text-anchor", d => d._children ? "end" : "start")
        .text(d => d.data.name)
      .clone(true).lower()
        .attr("stroke-linejoin", "round")
        .attr("stroke-width", 3)
        .attr("stroke", "white");

    // Transition nodes to their new position.
    const nodeUpdate = node.merge(nodeEnter).transition(transition)
        .attr("transform", d => `translate(${d.y},${d.x})`)
        .attr("fill-opacity", 1)
        .attr("stroke-opacity", 1);

    // Transition exiting nodes to the parent's new position.
    const nodeExit = node.exit().transition(transition).remove()
        .attr("transform", d => `translate(${source.y},${source.x})`)
        .attr("fill-opacity", 0)
        .attr("stroke-opacity", 0);

    // Update the links…
    const link = gLink.selectAll("path")
      .data(links, d => d.target.id);

    // Enter any new links at the parent's previous position.
    const linkEnter = link.enter().append("path")
        .attr("d", d => {
          const o = {x: source.x0, y: source.y0};
          return diagonal({source: o, target: o});
        });

    // Transition links to their new position.
    link.merge(linkEnter).transition(transition)
        .attr("d", diagonal);

    // Transition exiting nodes to the parent's new position.
    link.exit().transition(transition).remove()
        .attr("d", d => {
          const o = {x: source.x, y: source.y};
          return diagonal({source: o, target: o});
        });

    // Stash the old positions for transition.
    root.eachBefore(d => {
      d.x0 = d.x;
      d.y0 = d.y;
    });
  }

  update(root);

  return svg.node();
}
  </script>
  <script>
    var width = 960,
        height = 950,
        svg = d3.select("body").append("svg")
          .attr("width", width)
          .attr("height", height),
        g = svg.append("g"),
        cluster = d3.cluster()
          .size([2 * Math.PI, width / 2 - 150])
        fontSize = d3.scaleSqrt()
          .range([30, 7]);

    svg.append("rect")
      .attr("width", width)
      .attr("height", height)
      .style("fill", "none")
      .style("pointer-events", "all")
      .call(d3.zoom()
          .scaleExtent([1 / 2, 4])
          .on("zoom", zoomed));

    function zoomed() {
      g.attr("transform", d3.event.transform);
    }
    
    d3.json("JSON/namu.json", function (data){
      var hierarchy = d3.hierarchy(data);
      cluster(hierarchy);
      var descendants = hierarchy.descendants();
      
      fontSize.domain(d3.extent(descendants, function (d){ return d.depth; }))
      
      var link = g.selectAll(".link")
          .data(descendants.slice(1))
        .enter().append("path")
          .attr("class", "link")
          .attr("d", function(d) {
            if(d.parent === descendants[0]){
              return "M" + project(d.x, d.y)
                + " " + project(d.parent.x, d.parent.y);
            } else {
              return "M" + project(d.x, d.y)
                + "C" + project(d.x, (d.y + d.parent.y) / 2)
                + " " + project(d.parent.x, (d.y + d.parent.y) / 2)
                + " " + project(d.parent.x, d.parent.y);
            }
          });
      
      var node = g.selectAll(".node")
          .data(descendants)
        .enter().append("g")
          .attr("transform", function(d) {
            return "translate(" + project(d.x, d.y) + ")";
          });

      node.append("text")
        .text(function (d){
          return d.data.data.id;
        })
        .attr("font-size", function (d){
          return fontSize(d.depth) + "pt";
        })
        .attr("transform", function(d) {
          var theta = -d.x / Math.PI * 180 + 90;
          if(d.x > Math.PI){
            theta += 180;
          }
          if(d.depth !== 3 && Math.abs(theta) < 30){
            theta = 0;
          }
          if(d.depth > 1){
            return "rotate(" + theta + ")";
          } else {
            return "";
          }
        })
        .attr("text-anchor", function (d){
          if(d.depth === 3){
            return (d.x > Math.PI) ? "end" : "start";
          } else {
            return "middle";
          }
        })
        .attr("dx", function (d){
          if(d.depth === 3){
            return (d.x > Math.PI) ? "-2px" : "2px";
          } else {
            return "0px";
          }
        })
        .classed("glow", function (d){
          return d.depth !== 3;
        })
        .attr("alignment-baseline", "central");
    });
    
    function project(theta, r){
      return [
        width / 2 + r * Math.sin(theta),
        height / 2 + r * Math.cos(theta) + 4
      ]
    }
  </script>
</body>
